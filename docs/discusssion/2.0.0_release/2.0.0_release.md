# 2.0 Release

The development of Draftsman might have seemed to slow over the past few months, but this is not quite true. Instead, I've been spending the last half a year or so working on the next revision of the module which attempts to address the most fundamental problems with it. (Maybe there was *some* procrastination as well.) This has been no trivial matter, and what started as a simple set of minor updates ballooned into a massive major update which spans all of the current remaining issues with Draftsman, and hopefully leaves it in a better place going forward. This document gives an overview of what exactly I perceive these issues to be, as well as their new solutions in Draftsman 2.0.

## Deferred Validation

A big problem with Draftsman 1.0 is that it doesn't provide any real provisions for users working with blueprint configurations that Draftsman has no knowledge of. For example, consider the following case where we try to import a modded entity under a vanilla Factorio configuration:

```py
my_modded_blueprint = {
    "blueprint": {
        "item": "blueprint",
        "entities": [
            {
                "name": "my-modded-entity",
                "position": {"x": 0.5, "y": 0.5}
            }
        ]
    }
}

blueprint = Blueprint(my_modded_blueprint) # InvalidEntityError: 'my-modded-entity'
```

Draftsman complains because it doesn't recognize the entity, and thus cannot meaningfully check it's correctness. From Draftsman's perspective, this makes sense; what's the dimension of this entity? What does it collide with? Is it circuit connectable? What attributes does it have? What are their allowed values? Because Draftsman cannot validate this object to the caliber of an entity it does know, it decides to consider it a catastrophic error and defer to the user to either remove it or update Draftsman's environment.

This is great for a number of circumstances, such as the case where you thought you were operating in a modded context but actually weren't, or in the case where the entity's name was simply a misspelled version of a known entity, which you likely want to catch as early as possible.

The problem is that there are other situations where this is too restrictive. A user might very well want to just *ignore* any unknown entities/tiles and simply return a Blueprint with the known ones, which is in fact how Factorio itself behaves. Going further, you might want to actually preserve these modded entities in the created blueprint; you might want to swap the modded entity to a known one which Draftsman can handle, or maybe you don't want to touch the modded stuff at all and simply pass it to the game, asserting that they must be in a valid format and the game will know how to handle it even if Draftsman doesn't.

Because the members of `draftsman.data` are fully writable, you can add new entries in their corresponding dictionaries or lists to "trick" Draftsman into allowing these cases. Unfortunately, there are no helper methods which actually make this a palatable option. Care must be taken to provide all of the necessary information in the exact correct format  Draftsman expects, which is also likely to be inconsistent across Draftsman versions to boot. The only real sanctioned in Draftsman 1.0 for interacting with modded entities is to modify the entire data configuration by running `draftsman-update` (or the corresponding method in `env.py`). This is easy if you're creating the blueprint string yourself with a set of mods that you're actively playing with, but difficult if:

* You change your mod configuration to something different but still want to load the modded string under a different configuration,
* You receive the blueprint string from an external source which is running a different mod configuration (of which you may have no knowledge what mods were used!)
* You want to keep the script simple, and have it work with any environment configuration so that anyone can simply just run the script, dammit.

Clearly, this is a design flaw due to a simplification set early on when designing the tool. Since Draftsman runs the data lifecycle to extract validation information and can do so dynamically, I assumed that all of the needed data would be available at the script runtime, when this is not truly the case. As a result, Draftsman 1.0 is essentially a "greedy" validator, requiring comprehensive information about the entire environment before running, which is useful in some settings, but not in others.

Another related flaw about Draftsman 1.0 is that even if you *want* Draftsman to panic, you cannot tell it *when* to do so. Suppose for example that we want to swap all instances of a particular modded entity from a blueprint, but we still want to error if we detect any *other* modded entities. We would like to then write something similar to this:

```py
modded_string = "..."
blueprint = Blueprint(modded_string, validate=False)

for i, entity in blueprint.entities:
    if entity.name == "modded-lamp":
        blueprint.entities[i] = Lamp("small-lamp", position=entity.position)

blueprint.validate() # InvalidEntityError: 'my-modded-entity'
```

... but this is also impossible in Draftsman 1.0. Validation of the `Blueprint` always happens at construction, and cannot be deferred until later; the only other option is to modify the data going into `Blueprint` before constructing it, but this would be much more of a hassle and we wouldn't have access to all of the nice helper methods that `Blueprint` already provides, such as `find_entities_filtered()` or similar.

Finally, a user may also desire more control of the manner and types of warnings/errors which are issued. Some users might want to check just the format of the input data so that no fields have the incorrect type; others might want a comprehensive analysis of all of the field values, to check for redundancies or conceptual faults, treating Draftsman like a blueprint linter. You might want to treat errors as warnings, or warnings as errors, or perhaps ignore validation completely. What validation *should* do is more than a simple "yes" or "no", and so a big goal for 2.0 was to not only allow users to control when they can validate their inputs but also configure it to behave exactly as they want.

As a result, in **Draftsman 2.0** all Draftsman objects now have a `validate()` function which can be used to check their contents at any point after they're created. The function takes a `ValidationMode` parameter, which is an enum which indicates the strictness of the validation, which controls the type and quantity of errors and warnings:

* `NONE`: No validation whatsoever. Every attribute remains exactly as it was; even values in a known shorthand format are not converted. Impossible to know whether or not this object will import into Factorio when using this mode. This tells Draftsman to simply treat every object verbatim.
* `MINIMUM`: Only returns formatting errors, where data members are of incorrect types. For example, if you set the name of an entity to an integer, this would raise a `DataFormatError`. Besides this, no other warnings or errors are issued. This tells Draftsman to error if the object is in a form that it absolutely knows will NOT import into Factorio.
* `STRICT`: This is the default mode, most closely related to the behavior of Draftsman 1.0. It returns all above errors, as well as most of the errors and warnings most users of the module will be familiar with, in addition to a few new ones. For example, if Draftsman now encounters an entity it doesn't recognize, it issues a `UnknownEntityWarning` instead of an `InvalidEntityError`; Draftsman doesn't know about this entity, but it *may* import into Factorio if the game happens to know about it.
* `PEDANTIC`: Issues all above errors and warnings, as well as providing more linting-like behavior as well. A good example is setting the limiting bar of a container beyond it's total inventory slots; this creates no issue when importing into the game, and the container behaves as if the bar was set at that point; but it might indicate a conceptual failure from the programmers perspective or a simple mistake, and as such it will raise a `BarWarning` if detected under this validation mode.

Instead of raising the errors and warnings in place, `validate()` returns a wrapper object called a `ValidationResult`. This object contains an `error_list` and a `warning_list` attribute, which can be read, modified, iterated over, saved for later, or any combination thereof. This gives the user the ability to convert errors into warnings or warnings into errors, and it allows Draftsman to retain it's previous concepts of "Factorio-safety" and "Factorio-correctness" as the default while still allowing users to deviate from this behavior if required.

Most commonly, you'll probably end up writing something like this snippet, which simply reissues any detected errors or warnings found with a blueprint:

```py
blueprint = Blueprint()

# Construct the blueprint in some way...

result = blueprint.validate(mode=ValidationMode.STRICT)
for error in result.error_list:
    raise error
for warning in result.warning_list:
    warnings.warn(warning)
```

Because this particular pneumonic is likely to appear a lot, it's implemented as a helper method called `reissue_all()`:

```py
blueprint = Blueprint()

# Construct the blueprint in some way...

blueprint.validate(mode=ValidationMode.STRICT).reissue_all() # Identical to the above
```

Creating a `ValidationResult` object also makes it very easy to add other similar helper methods like this one as well as additional functionality later on without breaking code in written in earlier versions of 2.0.

Similar to their prior behavior, all `Blueprintable` and `Entity` subclasses still support validation during construction, with the addition of now being able to configure exactly how using the new keyword argument `validate`:

```py
messed_up_data = {
    "name": "unknown", # Should raise a warning
    "tags": "incorrect" # Should raise an error
}

container = Container(**messed_up_data, validate=ValidationMode.NONE) # No issues!
assert container.name == "unknown"
assert container.tags == "incorrect"
assert container.to_dict() == { # Even serialization still works
    "name": "unknown",
    "tags": "incorrect"
}

# Now validate it
result = container.validate()
assert len(result.error_list) == 1
```

In addition to the `validate` parameter, both `Blueprintable` and `Entity` subclasses also have a `validate_assignment` parameter, which configures whether or not to run validation when assigning an attribute of the object:

```py
container1 = Container(validate_assignment=ValidationMode.STRICT) # Default, 1.0 behavior

container1.name = TypeError          # Raises an error because of type mismatch
container1.name = "unknown"          # Raises a warning because it's not recognized
container1.name = "electric-furnace" # Raises a warning because it's not a Container

# `validate_assignment` can be set at any point in the objects lifetime
container1.validate_assignment = ValidationMode.NONE

container1.name = TypeError          # Nothing
container1.name = "unknown"          # Nothing
container1.name = "electric-furnace" # Nothing

# `validate_assignment` is a per-instance attribute, so individual entities/blueprints can have their own validation severity
container2 = Container(validate_assignment=ValidationMode.STRICT)

assert container.validate_assignment is not container2.validate_assignment
```

In an effort to provide more flexibility while still keeping the API consistent across many different functions and attributes, Draftsman now has 3 "categories" of manipulating data for all the validatable types:

1. Dict-like modification, such as `entity["member"] = ...`; This mode is guaranteed to not run validation ever, regardless of the value of `validate_assignment`, and does not abide by shorthand formats. As a consequence, this method is also guaranteed to be computationally cheap.
2. Attribute access, such as `entity.member = ...`; The behavior of this mode is configurable, depending on the value of `validate_assignment`. Usually the most terse syntax.
3. Helper function, such as `entity.set_member(...)`; This mode is guaranteed to run validation always, regardless of the value of `validate_assignment`. Also potentially provides additional functionality, such as setting defaults or formatting complex structures such as conditions, connections, etc.

In Draftsman 1.0, helper methods were used primarily for either setting attributes via shorthand, or for setting complex structures more easily. They retain these functions in 2.0, but now shorthands of all types can be used with the attribute syntax as well. Note however that shorthand resolution is tied to validation, so if validation is disabled in an entity's `validate_assignment`, it won't be able to handle shorthand formats automatically.

Finally, in addition to `validate` and `validate_assignment`, `EntityCollection` and `TileCollection` subclasses now also have an `if_unknown` string parameter which indicates what should happen if an unknown entity or tile is added to a blueprint or group. To illustrate this more clearly, let's take a look at `draftsman.entity.new_entity()` which also supports this keyword:

```py
from draftsman.error import InvalidEntityError, DataFormatError
from draftsman.entity import Entity, new_entity

# Regular, known entities work as you would expect without issue
container = new_entity("wooden-chest")
assert container.type == "container"

# By default, `if_unknown` is "error", which raises an exception
# (a la Draftsman 1.0's current behavior)
try:
    error_result = new_entity("unknown", if_unknown="error")
except InvalidEntityError:
    pass

# Setting to "ignore" simply returns nothing if unrecognized 
omitted_result = new_entity("unknown", if_unknown="ignore")
assert omitted_result is None

# "accept" is the final option, and is the most interesting
result = new_entity("unknown", position=(0.5, 0.5), if_unknown="accept")

# Result in this case is actually an instance of the base `Entity` parent class
assert isinstance(result, Entity)

# As a result, all of the parameters known to Entity are available, but none others
result.position += (10, 10)
result.tags = {"extra": "Tons of extra information we can use."}

# In addition, we can even add new parameters to this entity and Draftsman won't complain,
# which is different from a known container
# Draftsman asserts that the user knows that this keyword is available and it's value is correct
result["extra_parameter"] = "amazing!"

# We can then serialize this object with all keys intact
assert result.to_dict() == {
    "name": "unknown",
    "position": {"x": 10.5, "y": 10.5},
    "tags": {"extra": "Tons of extra information we can use."},
    "extra_parameter": "amazing!"
}

# And we can even still get validation for the few attributes we do know about!
try:
    result.tags = "incorrect" # DataFormatError: tags must be a dict
except DataFormatError:
    pass
```

This feature is passed down when appending a new entity or tile to a `Collection`:

```py
blueprint = Blueprint()

# We set validate to "minimum" here, otherwise UnknownEntityWarning and UnknownTileWarning would be issued
blueprint.entities.append("unknown-entity", validate="minimum", if_unknown="accept")
blueprint.tiles.append("unknown-tile", validate="minimum", if_unknown="accept")

print(blueprint)
# <Blueprint>{
#   "item": "blueprint",
#   "version": 281479277445120,
#   "entities": [
#     {
#       "name": "unknown-entity",
#       "position": {
#         "x": 0.0,
#         "y": 0.0
#       },
#       "entity_number": 1
#     }
#   ],
#   "tiles": [
#     {
#       "name": "unknown-tile",
#       "position": {
#         "x": 0,
#         "y": 0
#       }
#     }
#   ]
# }
```

# TODO: how to validate entities/tiles in their respective lists

`if_unknown` can also be passed into the constructor of a blueprint or group, as well as when using `load_from_string()`, so you can get this behavior when importing from an existing blueprint or blueprint string. This allows entity handling to be much more flexible, but there are still a few edge cases that I've yet to come up with an ergonomic solution for. For example, what if you wanted construct a blueprint with `"accept"`, but then wanted to issue errors for any unknown entity later on? Because they already exist as abstract `Entity` subclasses, calling validate won't detect them.

```py
blueprint = Blueprint("...", if_unknown="accept")

# Because all unknown entities are base class instances, you can check to see if
# it has the same type (which excludes any subclasses):
for entity in blueprint.entities:
    if type(entity) == Entity:
        raise RuntimeError("boo!")

# Alternatively, Draftsman also keeps a boolean flag indicating whether or not 
# the object has an unknown format:
for entity in blueprint.entities:
    if entity.unknown:
        raise RuntimeError("boo!")
```

I will be the first to admit that this is perhaps not the most consistent syntax, so suggestions for improvements are always welcome.

And finally, for those who just want to update Draftsman's data on the fly, there are now helper methods for all the class types in `draftsman.data` which allow you to add new or modify existing data:

```py
from draftsman.data import entities
from draftsman.entity import Container

entities.add_entity(
    name="new-container",
    entity_type="container",
    collision_box=((-0.4, -0.4), (0.4, 0.4)),
    inventory_size=100
    # Any other relevant keyword arguments can be provided and will be added to
    # the raw data entry
)

# "new-container" is now in all the correct places
assert "new-container" in entities.raw
assert "new-container" in entities.containers
# (NOTE: sort order is not currently preserved when adding at runtime)
# (This is harder than it sounds so I'm posteponing this until later)

container = Container("new-container")
assert (container.tile_width, container.tile_height) == (1, 1)
assert container.position == Vector(0.5, 0.5)
assert container.inventory_size == 100

# "new-container" will persist until the script ends
```

These methods are provided as a way to allow Draftsman to remain maximally strict against unknown data, but permit the user to quickly update said data just for the scope of a single script. This is provided mainly as a stopgap for cases where only a few entities/tiles are needed, which may be faster and/or simpler than grabbing the mod files themselves and running `draftsman-update`. In a future version, it might also make sense to have `draftsman-update` call these functions, meaning that this becomes the dedicated way to add/modify the Draftsman configuration dynamically (and thus only one place where it can break).

These new features will allow users of 2.0 to have much more control of the manner in which their structures are validated, hopefully making the module much more useful for a variety of new tasks. Of course, there is tons of room for improvement even with these additions, but while I can't quite remove it from the TODO list I feel much more comfortable now kicking that can down the road.

## Validation is now done with `pydantic` instead of `schema`

All of the above magic is facilitated with the [Pydantic](TODO) validation library. `schema` was showing it's inflexibility, was lacking a number of features I was looking for, and was altogether not very fast, so I started looking for a good replacement. I went through a number of different libraries before I finally settled on Pydantic; the primary reasons were:

* Pydantic schemas are defined using Python type hints instead of a custom internal language specific to the library, making it easier for other maintainers to contribute to the project and generally make the whole validation code much easier on the eyes.
* Pydantic allows to specify custom validation functions which can be run at basically any point during the validation step; before, after, during, and can even stop validation altogether halfway through. With conditional enabling/disabling of these functions, it should also be possible to make *version specific* checks to allow for not only consistent validation, but also validation specific to a particular Factorio version. Perhaps even users themselves could add their own custom validation functions; I'm still exploring the possibilities. Even if I don't stick with Pydantic ultimately (it has some problems I've yet to resolve), I firmly believe any future solution will need to have something like this in place.
* Warnings and errors are all integrated into one system, instead of having split and competing ones. In addition, *all* validation uses the same backend, which means that not only does `entity.items = {...}` issue the same warnings as `entity.set_items(...)`, but they both use the exact same code which is defined in one place, eliminating most of the bugs relating to validation being inconsistently performed.
* Pydantic supports JSON schema generation, meaning that you can take any Pydantic model and output an accurate JSON schema dictionary which describes it's exact format. This can then be extracted and used with *any* compliant JSON schema library to validate inputs of any Factorio blueprint string structure. Draftsman objects now have a `json_schema()` static method which can be used to dump this to a dictionary which can then be exported to other software. Furthermore, with a little bit of help it's highly likely that you could generate a human readable digest out of this information automatically, since the schema includes data type, value ranges, allowed values, etc. Because of this, almost all fields are given custom descriptions to not only make this feasible, but also highly likely in the future.

Additionally, the backend of Pydantic is written in Rust, which theoretically might lead to a considerable performance improvement (which was another longstanding issue with Draftsman), though due to the increased complexity of the validation, benchmarks will have to made to get any concrete conclusions. See the performance section below for more info on that.

Because Pydantic uses type hints to express it's schemas, this means that the new minimum Python version required will be Python 3.7. This also allows Draftsman to use a number of modern Python goodies that were previously precluded from it due to it's backwards compatibility restrictions. I honestly doubt there was anyone using my library on a version of Python *prior* to 3.7 anyway, but in case there was, Draftsman 1.0 will retain it's Python 2.0 compatibility and remain available on PYPI and under the `1.0` branch on Github. 1.0 will still receive bugfixes for the forseeable future, but all new features and the majority of new development will likely only exist on the main (2.0) branch going forward.

## `RailPlanner`, `Schedule`, `WaitConditions`, and `TrainConfiguration` (finally)

Another longstanding weak point of Draftsman was it's rudimentary API when interacting with rails, trains, and their schedules. In 2.0, this area has seen large improvements.

For placing rails, the long in-development `RailPlanner` class is now feature functional. It allows you to draw rail paths using turtle-like commands, entirely similar to how the game itself does it:

```py
from draftsman.blueprintable import Blueprint
from draftsman.rail import RailPlanner # New access point for rail related classes

# Create a new RailPlanner
# The name here refers to the vanilla rails, but you can change this to work with
# modded rails as well
planner = RailPlanner(name="rail")

# RailPlanners have a head position and direction, and can move forward, left, or right
planner.head_position = (0, 0)
planner.head_direction = Direction.SOUTH
planner.move_forward(5) # Place 5 straight rails southward
planner.turn_right()    # Turn 45 degrees to the right
planner.turn_left(3)    # Turn 135 degrees to the left, so we're now facing East
planner.move_forward(10)

# The head can be "picked-up" and oriented at any point
planner.head_position = (10, 10)
planner.head_direction = Direction.EAST
planner.move_forward(5)

# RailPlanners can also place rail signals (on either side of the track)...
planner.add_signal(entity="rail-signal")
planner.add_signal(entity="rail-chain-signal", right=False)
planner.move_forward(5)

# or train stops (on either side of the track)
planner.add_station(entity="train-stop", station="Name of Station")
planner.move_forward(5)

# Both of the above methods also allow you to pass in an existing entity instance
from draftsman.entity import TrainStop
configured_stop = TrainStop()
configured_stop.station = "Configured Station"
configured_stop.read_from_train = True
planner.add_station(entity=configured_stop)

# Now we can simply add the planner to a blueprint
blueprint = Blueprint()
blueprint.entities.append(planner)
print(blueprint.to_string())
```

`RailPlanner` is a superclass of `Group`, so all of the convenience methods available to it are provided as well, such as filtered searching, transformations, as well as positioning the entire set of rails all at once.

`TrainConfiguration` allows you to specify a sequence of rolling stock in the community-accepted syntax for describing trains:

```py
from draftsman.rail import TrainConfiguration
from draftsman.entity import Locomotive, CargoWagon

# Trains are defined from left to right where left is the front of the train
config = TrainConfiguration("1-4")

# `cars` is a list of rolling stock corresponding to each car, where the 
# beginning of the list is the beginning of the train
print(len(config.cars)) # 5

# entries in `cars` are regular entities, which means they support everything
# you would expect:
# Request fuel to the locomotive
assert isinstance(config.cars[0], Locomotive)
config.cars[0].set_item_request("nuclear-fuel", 3) 
# Set the limiting bar for every following cargo wagon
for i in range(1, len(config.cars)):
    assert isinstance(config.cars[i], CargoWagon)
    config.cars[i].bar = 5

# You can also get things like the amount of rails needed to place this train in
# a straight line, which is useful for RailPlanner
print(config.rail_length) # 18
```

The syntax that Draftsman uses is a superset of the community version, which allows enough flexibility to specify any arbitrary train format. See `examples/train_configuration_usage.py` for much more info about that syntax and how it works.

Once you have a train, you likely want to give it a schedule. Conditions are specified with `WaitCondition` and `WaitConditions` objects:

```py
from draftsman.rail import Schedule, WaitCondition

# Create a schedule object
schedule = Schedule()

# Individual conditions can be specified with particular parameters
cargo_full = WaitCondition("full")
cargo_empty = WaitCondition("empty")
inactivity = WaitCondition("inactivity", ticks=300) # 5 seconds

# To make it easier to specify multiple conditions together, `WaitConditions`
# objects can be made by combining wait conditions with AND and OR bitwise 
# operators
station_a_conditions = cargo_full | inactivity

# Adds a stop at station(s) with name "A"
schedule.append_stop(name="A", wait_conditions=station_a_conditions)
# This method correctly handles receiving a single WaitCondition object as well
schedule.append_stop("B", cargo_empty)
```

Then it can simply be added to a blueprint in 2 convenient ways:

```py
# Simply adds a train going straight at a particular position and direction
blueprint.add_train_at_position(config, (10, 10), Direction.NORTH, schedule)

# Finds a particular station in the blueprint and places the train behind it
blueprint.add_train_at_station(config, blueprint.entities["station_entity"], schedule)

# (NOTE: neither function handles curves when placed on rails, at time of writing)
```

`schedule` can of course be omitted in case don't want the train to be set with a schedule. If you do specify a schedule, the schedule object will be added to the blueprint's `schedules` list, which can be inspected or modified in many different ways.

```py
# Import a blueprint with trains with schedules
blueprint = Blueprint("...")

# Delete all schedules
blueprint.schedules = []

# ... or remove all trains from each schedule, but save the schedules themselves
for schedule in blueprint.schedules:
    schedule.locomotives = []

# ... or add a new schedule and change every train with an existing schedule to
# use the new schedule
new_schedule = Schedule()

for schedule in blueprint.schedules:
    new_schedule.locomotives += schedule.locomotives
    schedule.locomotives = []

blueprint.schedules.append(new_schedule)

# etc...
```

If you find a particular locomotive in a blueprint that you want to give a particular schedule, you can use the new `set_train_schedule()` helper method:

```py
locos = blueprint.find_entities_filtered(type="locomotive")

# This function not only sets the schedule of these particular locomotives, but
# also traverses any connected train cars and sets any connected locomotives to
# have the same schedule as well
blueprint.set_train_schedule(locos, some_schedule)
```

You can also use the newly added `find_trains_filtered()` function to grab a very particular set of trains in a blueprint/group:

```py
# Get all trains with a particular schedule less than 5 wagons long and give them
# a new schedule
trains = blueprint.find_trains_filtered(schedule=some_schedule, train_length=(0, 5))
for train in trains:
    blueprint.set_train_schedule(train, new_schedule)

# Remove all trains with a different schedule
trains = blueprint.find_trains_filtered(schedule=some_other_schedule)
for train in trains:
    blueprint.remove_train(train)
```

For more detail on how to use all the features of the new rail-oriented classes, see [the examples folder](TODO).

## Numerous Additional Quality of Life Features

2.0 also provides a number of features over 1.0 that should allow to write much more ergonomic code:

1. `Direction` and `Orientation` are now more than just normal enumerations, and support all of the methods supported with the [Factorio Standard Library](http://afforess.github.io/Factorio-Stdlib/):

```py
>>> from draftsman.constants import Direction, Orientation
>>> Direction.NORTH.opposite()
<Direction.SOUTH: 4>
>>> Direction.NORTH.next()
<Direction.EAST: 2>
>>> Direction.NORTH.previous(eight_way=True)
<Direction.NORTHWEST: 7>
>>> Direction.NORTH.to_vector()
<Vector>(0, -1)
>>> Direction.NORTH.to_orientation()
<Orientation.NORTH: 0.0>
>>> Orientation.NORTH.to_direction()
<Direction.NORTH: 0>
>>> Orientation.NORTH.to_vector(magnitude=10)
<Vector>(0, -10)
```

The `Ticks` constant class has also been added, which should make translating time-based periods much easier:

```py
from draftsman.constants import Ticks

assert Ticks.SECOND == 60
assert 5 * Ticks.SECOND == 300
print(Ticks.__members__.keys()) # dict_keys(['SECOND', 'MINUTE', 'HOUR', 'DAY'])

# You can even convert `timedeltas` to ticks
from datetime import datetime
t1 = datetime.strptime("10:15:04", "%H:%M:%S")
t2 = datetime.strptime("10:19:27", "%H:%M:%S")
td = t2 - t1
print(Ticks.from_timedelta(td)) # 15780
```

Both `EntityList` and `TileList` now support set operations like union, intersection, and difference, with custom operators to boot:

```

```

* `position` and `tile_position` now properly update the other when modifying by attribute `x` or `y`; Example:
* You can now manually specify the `index` of a Blueprintable in a blueprint book manually instead of rearranging the blueprint's list. This allows not only for flexibility, but it also now allows you to specify blueprint books with non-contiguous blueprint entries, which you were previously unable to do in `1.0`.
* A few more example scripts in the `examples` folder, but more excitingly examples are now organized into category directories, and a README.md is provided in each directory which gives an overview of each example.
* `to_dict()` for all functions now have two parameters, `exclude_none` and `exclude_default`. They default to `True`, but can be turned off if you want to ensure that every supplied key makes it out for data consistency reasons. For those worried about blueprint string size, fear not; `to_string()` still uses the minimum format possible, and may even be smaller now than in 1.0.


Of course, documentation has all been updated to illustrate all of these new features, and a new branch on ReadTheDocs has been made to differentiate between 1.0 and 2.0.

## Performance improvements

Another longstanding issue with Draftsman was it's performance, particularly with large blueprints. In 2.0, this is mitigated with the aforementioned switch to Pydantic, as well as a massive trimming of memory usage for Draftsman constructs.

### Reduced memory footprint

* Almost all information known to the class is now at the class level
    - Before, things like the `rotatable` entity flag were kept as members in each entity instance, even though it's the same for all instances of a particular entity. This is now fixed.

Lots of parameters are now calculated as needed instead of cached. For most attributes, this is perfectly fine.
    - This has the benefit of reducing memory footprint further as well as only performing the calculation when the user actually needs it
    - If the user doesn't want to recalculate it every time, they can choose to cache it at their own discretion

## Future work

* While validation is a lot better now and much more flexible, it's not quite perfect; a lot of the internal cruft still remains
* `is_valid` attribute for validation caching
    - This would be very nice, but it is also very complex with the current structure of the project

The list of things TODO has now moved to a dedicated document, with more information about each component. If you're interested in contributing, it should now be easier to see my intentions for the project going forward.